
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>TNM084 Project</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				color:#000;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: red;
			}
		</style>

		<script type="text/javascript" src="js/dat.gui.js"></script>

		<!-- GUI -->
		<script type="text/javascript">
		GuiContent = function() {
			this.depth = 1.0;
			//this.explode = function() {};
		};

		var gui_content;

		window.onload = function() {
			gui_content = new GuiContent();
			var gui = new dat.GUI();
			gui.add(gui_content, 'depth', 1, 10);
			//gui.add(gui_content, 'explode');
		};
		</script>
		
	</head>

	<body>
		<div id="container"></div>

		<!-- Shaders -->
		<script type="x-shader/x-vertex" id="vertexshader">

			/* HERE COMES THE NOISE */

			vec3 mod289(vec3 x) {
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}

			vec4 mod289(vec4 x) {
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}

			vec4 permute(vec4 x) {
				return mod289(((x*34.0)+1.0)*x);
			}

			vec4 taylorInvSqrt(vec4 r)
			{
				return 1.79284291400159 - 0.85373472095314 * r;
			}

			float snoise(vec3 v)
			{ 
				const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
				const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

				// First corner
				vec3 i  = floor(v + dot(v, C.yyy) );
				vec3 x0 =   v - i + dot(i, C.xxx) ;

				// Other corners
				vec3 g = step(x0.yzx, x0.xyz);
				vec3 l = 1.0 - g;
				vec3 i1 = min( g.xyz, l.zxy );
				vec3 i2 = max( g.xyz, l.zxy );

				//   x0 = x0 - 0.0 + 0.0 * C.xxx;
				//   x1 = x0 - i1  + 1.0 * C.xxx;
				//   x2 = x0 - i2  + 2.0 * C.xxx;
				//   x3 = x0 - 1.0 + 3.0 * C.xxx;
				vec3 x1 = x0 - i1 + C.xxx;
				vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
				vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

				// Permutations
				i = mod289(i); 
				vec4 p = permute( permute( permute( 
				         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				       + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
				       + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

				// Gradients: 7x7 points over a square, mapped onto an octahedron.
				// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
				float n_ = 0.142857142857; // 1.0/7.0
				vec3  ns = n_ * D.wyz - D.xzx;

				vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

				vec4 x_ = floor(j * ns.z);
				vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

				vec4 x = x_ *ns.x + ns.yyyy;
				vec4 y = y_ *ns.x + ns.yyyy;
				vec4 h = 1.0 - abs(x) - abs(y);

				vec4 b0 = vec4( x.xy, y.xy );
				vec4 b1 = vec4( x.zw, y.zw );

				//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
				//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
				vec4 s0 = floor(b0)*2.0 + 1.0;
				vec4 s1 = floor(b1)*2.0 + 1.0;
				vec4 sh = -step(h, vec4(0.0));

				vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
				vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

				vec3 p0 = vec3(a0.xy,h.x);
				vec3 p1 = vec3(a0.zw,h.y);
				vec3 p2 = vec3(a1.xy,h.z);
				vec3 p3 = vec3(a1.zw,h.w);

				//Normalise gradients
				vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
				p0 *= norm.x;
				p1 *= norm.y;
				p2 *= norm.z;
				p3 *= norm.w;

				// Mix final noise value
				vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
				m = m * m;
				return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
				                            dot(p2,x2), dot(p3,x3) ) );
			}

			/* HERE ENDS THE NOISE */

			// switch on high precision floats
			#ifdef GL_ES
			precision highp float;
			#endif
			
			uniform float time;
			uniform float sunPositionX;
			uniform float sunPositionY;
			uniform float sunPositionZ;
			uniform float planeWidth;
			uniform float planeHeight;
			uniform float seaDepth;
			uniform float skyHeight;
			uniform float amplGain;
			uniform vec3 cameraPosWorldSpace;

			varying vec3 interpolatedNormalViewSpace;
			varying vec3 interpolatedNormalWorldSpace;
			varying vec3 lightDirectionViewSpace;
			varying vec4 fragWorldPos;
			varying vec4 lightPositionWorldSpace;
			vec3 randVector;

			void main()
			{
				vec3 timeVector = 0.3 * vec3(0.0, time, time);
				vec3 stretchVector_lowFreq = vec3(0.35, 1.0, 1.0);
				vec3 stretchVector_medFreq = vec3(0.5, 1.0, 1.0);
				vec3 periodVector = vec3(50.0, 50.0, 50.0);

				float texScale = 0.0005;

				// Three frequencies of noise
				float freq_low = 7.0 / amplGain;
				float freq_mid = 67.0;

				// Perlin noise function calls, returning [-1, 1]
				float n1 = snoise(texScale * position.xyz * stretchVector_lowFreq * freq_low + timeVector * 0.5);
				float n2 = snoise(texScale * position.xyz * stretchVector_medFreq * freq_mid + timeVector);

				// Displacement
				float ampl_lowFreq = 15.0 * (1.5 * amplGain);
				float ampl_mediumFreq = 0.25;
				float displacement = ampl_lowFreq * n1 + ampl_mediumFreq * n2;
				
				// New, displaced position
				vec3 displacedPosition = position.xyz + displacement * normal;
				gl_Position = projectionMatrix * modelViewMatrix * vec4(displacedPosition, 1.0);

				/* --- Approximating new normals --- */
				
				// Forward difference sample points
				float h = 0.1;
				vec3 forwardPointX = vec3(position.x + h, position.y, position.z);
				vec3 forwardPointY = vec3(position.x, position.y + h, position.z);

				// X-axis
				// Noise value at sample point
				float dnx1 = snoise(texScale * forwardPointX * stretchVector_lowFreq * freq_low + timeVector * 0.5);
				float dnx2 = snoise(texScale * forwardPointX * stretchVector_medFreq * freq_mid + timeVector);

				// Displacement
				float forwardPointXDisp = ampl_lowFreq * dnx1 + ampl_mediumFreq * dnx2;
				vec3 forwardPointXDispPos = forwardPointX + forwardPointXDisp * normal;

				// Y-axis
				// Noise value at sample point
				float dny1 = snoise(texScale * forwardPointY * stretchVector_lowFreq * freq_low + timeVector * 0.5);
				float dny2 = snoise(texScale * forwardPointY * stretchVector_medFreq * freq_mid + timeVector);

				// Displacement
				float forwardPointYDisp = ampl_lowFreq * dny1 + ampl_mediumFreq * dny2;
				vec3 forwardPointYDispPos = forwardPointY + forwardPointYDisp * normal;

				// Difference vectors
				vec3 diffVectorX = normalize(displacedPosition - forwardPointXDispPos);
				vec3 diffVectorY = normalize(displacedPosition - forwardPointYDispPos);

				// New normal
				vec3 newNormal = normalize(cross(diffVectorX, diffVectorY));

				// Transformation of 'varyings'
				interpolatedNormalWorldSpace = normalize(mat3(modelMatrix) * newNormal);
				interpolatedNormalViewSpace = normalize(mat3(modelViewMatrix) * newNormal);
				lightDirectionViewSpace = normalize(mat3(viewMatrix) * normalize(vec3(0.0, 1.0, 1.0)));
				lightPositionWorldSpace = vec4(sunPositionX, sunPositionY, sunPositionZ, 1.0);
				fragWorldPos = vec4(displacedPosition, 1.0) * modelMatrix;
			}
			
		</script>
		
		<script type="x-shader/x-fragment" id="fragmentshader">
		
			#ifdef GL_ES
			precision highp float;
			#endif

			/* HERE COMES THE NOISE */

			vec3 mod289(vec3 x) {
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}

			vec4 mod289(vec4 x) {
				return x - floor(x * (1.0 / 289.0)) * 289.0;
			}

			vec4 permute(vec4 x) {
				return mod289(((x*34.0)+1.0)*x);
			}

			vec4 taylorInvSqrt(vec4 r)
			{
				return 1.79284291400159 - 0.85373472095314 * r;
			}

			float snoise(vec3 v)
			{ 
				const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
				const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

				// First corner
				vec3 i  = floor(v + dot(v, C.yyy) );
				vec3 x0 =   v - i + dot(i, C.xxx) ;

				// Other corners
				vec3 g = step(x0.yzx, x0.xyz);
				vec3 l = 1.0 - g;
				vec3 i1 = min( g.xyz, l.zxy );
				vec3 i2 = max( g.xyz, l.zxy );

				//   x0 = x0 - 0.0 + 0.0 * C.xxx;
				//   x1 = x0 - i1  + 1.0 * C.xxx;
				//   x2 = x0 - i2  + 2.0 * C.xxx;
				//   x3 = x0 - 1.0 + 3.0 * C.xxx;
				vec3 x1 = x0 - i1 + C.xxx;
				vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
				vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

				// Permutations
				i = mod289(i); 
				vec4 p = permute( permute( permute( 
				         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				       + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
				       + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

				// Gradients: 7x7 points over a square, mapped onto an octahedron.
				// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
				float n_ = 0.142857142857; // 1.0/7.0
				vec3  ns = n_ * D.wyz - D.xzx;

				vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

				vec4 x_ = floor(j * ns.z);
				vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

				vec4 x = x_ *ns.x + ns.yyyy;
				vec4 y = y_ *ns.x + ns.yyyy;
				vec4 h = 1.0 - abs(x) - abs(y);

				vec4 b0 = vec4( x.xy, y.xy );
				vec4 b1 = vec4( x.zw, y.zw );

				//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
				//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
				vec4 s0 = floor(b0)*2.0 + 1.0;
				vec4 s1 = floor(b1)*2.0 + 1.0;
				vec4 sh = -step(h, vec4(0.0));

				vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
				vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

				vec3 p0 = vec3(a0.xy,h.x);
				vec3 p1 = vec3(a0.zw,h.y);
				vec3 p2 = vec3(a1.xy,h.z);
				vec3 p3 = vec3(a1.zw,h.w);

				//Normalise gradients
				vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
				p0 *= norm.x;
				p1 *= norm.y;
				p2 *= norm.z;
				p3 *= norm.w;

				// Mix final noise value
				vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
				m = m * m;
				return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
				                            dot(p2,x2), dot(p3,x3) ) );
			}

			/* HERE ENDS THE NOISE */

			uniform float time;
			uniform float sunPositionX;
			uniform float sunPositionY;
			uniform float sunPositionZ;
			uniform float seaDepth;
			uniform float skyHeight;
			uniform float planeWidth;
			uniform float planeHeight;
			uniform vec3 cameraPosWorldSpace;
			uniform sampler2D skyTexture;
			uniform sampler2D seabedTexture;

			varying vec3 vTexCoord3D;
			varying vec3 interpolatedNormalViewSpace;
			varying vec3 interpolatedNormalWorldSpace;
			varying vec3 lightDirectionViewSpace;
			varying vec4 fragWorldPos;
			varying vec4 lightPositionWorldSpace;
	
			void main()
			{
				vec3 diffuseColor = vec3(0.1, 0.2, 0.5);
				vec3 specularColor = vec3(1.0, 1.0, 1.0);
				vec3 viewDirectionWorldSpace = -normalize(cameraPosWorldSpace - fragWorldPos.xyz);
				vec3 lightDirectionWorldSpace = normalize(fragWorldPos.xyz - lightPositionWorldSpace.xyz);

				float specularPower = 256.0;

				// Diffuse lighting, sky (world space)
				// ===================================

				float diffuseLighting = max(0.0, dot(vec3(0.0, 0.0, 1.0), interpolatedNormalWorldSpace));
				diffuseLighting = pow(diffuseLighting, 10.0);

				// Specular lighting, sun (world space)
				// ====================================

				// Compute reflection direction vector (Blinn-Phong)
				vec3 reflectionWorldSpace = 2.0 * interpolatedNormalWorldSpace * dot(interpolatedNormalWorldSpace, lightDirectionWorldSpace) - (lightDirectionWorldSpace);
				float specularLighting = pow(max(0.0, dot(reflectionWorldSpace, viewDirectionWorldSpace)), specularPower);

				// Reflection (sky)
				// ================

				// Compute reflection direction vector (Blinn-Phong)
				vec3 reflectionDirWorldSpace = normalize(2.0 * interpolatedNormalWorldSpace * dot(interpolatedNormalWorldSpace, viewDirectionWorldSpace) - (viewDirectionWorldSpace));

				// Glossy reflection

				// Get normalized object coordinates
				float px = fragWorldPos.x / planeWidth + 0.5;
				float py = fragWorldPos.y / planeHeight + 0.5;

				// Compute angle between reflection and 'up' vector
				float cos_alpha = dot(vec3(0.0, 0.0, 1.0), reflectionDirWorldSpace);
				float alpha = acos(cos_alpha);

				// Compute sampling offset
				float offset_x = tan(alpha) * skyHeight * reflectionDirWorldSpace.x;
				float offset_y = tan(alpha) * skyHeight * reflectionDirWorldSpace.y;

				// Compute new sampling position (uv coordinates)
				float samplePos_x = px + offset_x;
				float samplePos_y = py + offset_y;

				// Texture tiling/repeating
				samplePos_x = (samplePos_x < 0.0) ? mod(samplePos_x + 1.0, 1.0) : mod(samplePos_x, 1.0);
				samplePos_y = (samplePos_y < 0.0) ? mod(samplePos_y + 1.0, 1.0) : mod(samplePos_y, 1.0);

				// Create 2D uv coordinates
				vec2 texCoord2D_sky = vec2(samplePos_x, samplePos_y);
				// Sample seabed texture at these coordinates
				vec4 reflectionColor = texture2D(skyTexture, texCoord2D_sky);

				// Refraction (seabed)
				// ===================

				// Compute refraction direction vector
				vec3 refractionDirWorldSpace = refract(viewDirectionWorldSpace, interpolatedNormalWorldSpace, 0.75);

				// Compute angle between refraction and 'down vector'
				cos_alpha = dot(vec3(0.0, 0.0, -1.0), refractionDirWorldSpace);
				alpha = acos(cos_alpha);

				// Compute sampling offset
				offset_x = tan(alpha) * seaDepth * refractionDirWorldSpace.x;
				offset_y = tan(alpha) * seaDepth * refractionDirWorldSpace.y;

				// Compute distance traveled (hypothenuse)
				float refractionDist = cos_alpha / seaDepth;

				// Compute new sampling position (uv coordinates)
				samplePos_x = px + offset_x;
				samplePos_y = py + offset_y;

				// Texture tiling/repeating
				samplePos_x = (samplePos_x < 0.0) ? mod(samplePos_x + 1.0, 1.0) : mod(samplePos_x, 1.0);
				samplePos_y = (samplePos_y < 0.0) ? mod(samplePos_y + 1.0, 1.0) : mod(samplePos_y, 1.0);

				// Create 2D uv coordinates
				vec2 texCoord2D_seabed = vec2(samplePos_x, samplePos_y);
				// Sample seabed texture at these coordinates
				vec4 refractionColor = texture2D(seabedTexture, texCoord2D_seabed) * refractionDist;

				// Composite diffuse (sky), specular (sun) and reflection (sky texture)
				// ====================================================================

				// Compute angle between view direction and surface normal
				cos_alpha = abs(dot(viewDirectionWorldSpace, interpolatedNormalWorldSpace));

				gl_FragColor = (0.25 + 0.5 * cos_alpha) * refractionColor + (0.25 + 0.5 * (1.0 - cos_alpha)) * reflectionColor + 0.0 * vec4(diffuseColor * diffuseLighting + specularColor * specularLighting, 1.0);
			}
		
		</script>
		
		<!-- End Shaders -->
		
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/controls/TrackballControls.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats, start;
			var pauseTime = 0.0;
			var elapsedPauseTime = 0.0;
			var animationIsPaused = false;
			var camera, controls, scene, renderer;
			var uniforms;
			var sphere;
			var sunPosition_x = -200.0;
			var sunPosition_y = 2000.0;
			var sunPosition_z = 300.0;
			var plane_width  = 1200;
			var plane_height = 1200;
			var sea_depth = 1.0;
			var sky_height = 1.0;
			var ampl_gain = 1.0;
			var sky_tex;

			document.addEventListener("keyup", function(event) { 
				if(event.which == 32) {
					if(!animationIsPaused) {
						pauseTime = Date.now();
					} else {
						start += elapsedPauseTime;
					}
					animationIsPaused = !animationIsPaused;
				}
			}, false);

			init();

			function animate() {
				//console.log("Animating!");
				requestAnimationFrame(animate);
				controls.update();
				render();
			}

			function init() {

				start = Date.now();

				// Camera
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.z = 500;

				// Scene
				scene = new THREE.Scene();
				scene.fog = new THREE.FogExp2( 0x000000, 0.002 );

				// World
				var geometry = new THREE.PlaneGeometry( plane_width, plane_height, 128, 128);

				sky_tex = THREE.ImageUtils.loadTexture( "img/tex_sky_07.png" );
				sky_tex.minFilter = THREE.LinearFilter;

				var seabed_tex = THREE.ImageUtils.loadTexture( "img/tex_seabed_01.png" );
				seabed_tex.minFilter = THREE.LinearFilter;

				// Shader uniforms
				uniforms = {
				    time: { type: "f", value: start},
				    sunPositionX: { type: "f", value: sunPosition_x},
				    sunPositionY: { type: "f", value: sunPosition_y},
				    sunPositionZ: { type: "f", value: sunPosition_z},
				    planeWidth: { type: "f", value: plane_width},
				    planeHeight: { type: "f", value: plane_height},
				    seaDepth: { type: "f", value: sea_depth},
				    skyHeight: { type: "f", value: sky_height},
				    amplGain: { type: "f", value: ampl_gain},
				    cameraPosWorldSpace: { type: "v3", value: new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z)},
				    // Textures
					skyTexture : { type: "t", value: sky_tex},
					seabedTexture : { type: "t", value: seabed_tex },
				};

				// create the custom material
				var shaderMaterial = new THREE.ShaderMaterial({
					uniforms: uniforms,
					vertexShader:   $('#vertexshader').text(),
					fragmentShader: $('#fragmentshader').text(),
					wireframe: false,
				});

				var waterSurface = new THREE.Mesh( geometry, shaderMaterial );
				waterSurface.position.x = 0;
				waterSurface.position.y = 0;
				waterSurface.position.z = 0;
				//waterSurface.rotation.x = 2.0;
				waterSurface.updateMatrix();
				waterSurface.matrixAutoUpdate = false;
				scene.add( waterSurface );

				console.log(waterSurface.position.y);

				// Sun sphere
				var geometry = new THREE.SphereGeometry( 10, 32, 32 );
				var material = new THREE.MeshBasicMaterial( {color: ("rgb(255, 0, 0)")} );

				sphere = new THREE.Mesh( geometry, material );
				scene.add( sphere );
				sphere.position.set(sunPosition_x, sunPosition_y, sunPosition_z);

				// renderer
				renderer = new THREE.WebGLRenderer( { antialias: false } );
				renderer.setClearColor( scene.fog.color );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );

				// Controls
				controls = new THREE.TrackballControls( camera, renderer.domElement );
				controls.rotateSpeed = 2.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
				controls.keys = [ 65, 83, 68 ];

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

				animate();
			}

			function onWindowResize()
			{
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function render()
			{
				//console.log("Rendering!");
				sunPosition_x = 4.0 * Math.sin(0.001 * (Date.now() - start)) * 100;
				uniforms.sunPositionX.value = sunPosition_x;
				sphere.position.set(sunPosition_x, sunPosition_y, sunPosition_z);
				uniforms.cameraPosWorldSpace.value = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
				uniforms.seaDepth.value = gui_content.depth;
				uniforms.amplGain.value = 0.9 + 0.1 * gui_content.depth;
				renderer.render( scene, camera );
				if(!animationIsPaused)
				{
					uniforms.time.value = 0.0025 * (Date.now() - start);
				} else {
					elapsedPauseTime = Date.now() - pauseTime;
				}
				stats.update();
			}

		</script>

	</body>
</html>
